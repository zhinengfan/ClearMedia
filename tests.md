### **ClearMedia 项目测试用例指南**

**核心测试理念:**
我们将采用`pytest`作为测试框架。测试将分为**单元测试**（测试单个模块/函数）和**集成测试**（测试多个模块协同工作的流程）。我们将大量使用**Mocks（模拟）**来隔离外部依赖（如LLM/TMDB API），并使用**Fixtures（固定装置）**来创建可复用的测试环境（如内存数据库、虚拟文件系统）。

**推荐的测试库(已安装):**
*   `pytest`: 核心测试框架。
*   `pytest-mock`: 方便地模拟对象和函数。
*   `pyfakefs`: 创建一个虚拟的内存文件系统，用于测试所有文件操作。

---

#### **1. `config.py` - 配置模块单元测试 (`test_config.py`)**

*   **测试用例 1.1: 成功加载配置**
    *   **Given:** 一个包含所有必需变量的有效`.env`文件。
    *   **When:** `Settings`类被实例化。
    *   **Then:** `settings`对象的属性值与`.env`文件中的值完全匹配。

*   **测试用例 1.2: 缺少环境变量**
    *   **Given:** 一个缺少了`TMDB_API_KEY`等必需变量的`.env`文件。
    *   **When:** `Settings`类被实例化。
    *   **Then:** 程序应抛出`pydantic_settings`的验证错误 (Validation Error)。

---

#### **2. `scanner.py` - 扫描器单元测试 (`test_scanner.py`)**
*(需要使用 `pyfakefs` 模拟文件系统和 `pytest-mock` 模拟数据库交互)*

*   **测试用例 2.1: 发现新文件**
    *   **Given:** "源目录"中存在一个数据库中没有记录的新视频文件。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数被以正确的文件路径、inode、device_id和`PENDING`状态调用了一次。

*   **测试用例 2.2: 忽略已处理的文件**
    *   **Given:** "源目录"中存在一个文件，其inode和device_id在数据库中已存在，状态为`COMPLETED`。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

*   **测试用例 2.3: 忽略处理失败的文件**
    *   **Given:** "源目录"中存在一个文件，其inode和device_id在数据库中已存在，状态为`FAILED`。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

*   **测试用例 2.4: 忽略非视频文件**
    *   **Given:** "源目录"中出现了一个`.txt`或`.nfo`文件。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

---

#### **3. `llm.py` - LLM交互单元测试 (`test_llm.py`)**
*(需要使用 `pytest-mock` 模拟`openai`客户端)*

*   **测试用例 3.1: 成功解析规范文件名**
    *   **Given:** 输入文件名 "Dune.Part.Two.2024.1080p.mkv"。
    *   **When:** 调用LLM分析函数。
    *   **Then:** 函数应返回一个类似 `{"title": "Dune Part Two", "year": "2024", "type": "movie"}` 的JSON对象。

*   **测试用例 3.2: 优雅处理不规范文件名**
    *   **Given:** 输入文件名 "沙丘2.mkv"。
    *   **When:** 调用LLM分析函数。
    *   **Then:** 函数应能返回一个合理的猜测结果，例如 `{"title": "沙丘2", "year": null, "type": "movie"}`。

*   **测试用例 3.3: API调用失败与重试**
    *   **Given:** 模拟`openai`客户端在前两次调用时抛出`APIError`，第三次调用时成功。
    *   **When:** 调用LLM分析函数（该函数已被`@tenacity.retry`装饰）。
    *   **Then:** 函数最终成功返回结果，并且可以断言底层的API客户端被调用了**3次**。

*   **测试用例 3.4: 验证缓存机制**
    *   **Given:** 模拟`openai`客户端。
    *   **When:** 使用**相同的**文件名连续调用LLM分析函数（该函数已被`@functools.lru_cache`装饰）两次。
    *   **Then:** 底层的API客户端应该只被调用了**1次**。

---

#### **4. `tmdb.py` - TMDB交互单元测试 (`test_tmdb.py`)**
*(需要使用 `pytest-mock` 模拟 `tmdbsimple` 和 `asyncio.to_thread`)*

*   **测试用例 4.1: 成功找到匹配项**
    *   **Given:** 输入从LLM获取的有效数据 `{"title": "Dune Part Two", "year": "2024"}`。
    *   **When:** 调用TMDB搜索函数。
    *   **Then:** 函数应返回一个包含正确TMDB ID和媒体信息的对象。

*   **测试用例 4.2: 未找到匹配项**
    *   **Given:** 输入一个无法匹配任何电影的数据 `{"title": "一部不存在的电影", "year": "1900"}`。
    *   **When:** 调用TMDB搜索函数。
    *   **Then:** 函数应返回`None`或一个表示失败的空结果。

*   **测试用例 4.3: 验证异步包装**
    *   **Given:** 任何有效的输入。
    *   **When:** `await`调用TMDB搜索函数。
    *   **Then:** `asyncio.to_thread`应该被调用，并且函数应成功执行完毕，没有阻塞测试的事件循环。

---

#### **5. `linker.py` - 文件链接器单元测试 (`test_linker.py`)**
*(需要使用 `pyfakefs` 模拟文件系统)*

*   **测试用例 5.1: 成功创建硬链接**
    *   **Given:** 源文件和目标目录在同一个模拟设备上。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 目标路径下出现了一个新的硬链接文件，并且该函数返回成功状态。

*   **测试用例 5.2: 目标路径已存在冲突**
    *   **Given:** 目标路径下已经存在一个同名文件。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 底层的`os.link`**未被调用**，函数返回一个`CONFLICT`状态。

*   **测试用例 5.3: 跨设备链接失败**
    *   **Given:** 模拟`os.link`在被调用时抛出`OSError`（特别是`errno.EXDEV`）。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 函数能捕获这个异常，并返回一个`FAILED`状态。

---

#### **6. `queue.py` & `processor.py` - 集成测试 (`test_processing_flow.py`)**
*(需要真实的内存SQLite数据库和模拟的API/文件系统)*

*   **测试用例 6.1: 端到端成功流程**
    *   **Given:** 在虚拟文件系统中有一个新文件 "Inception.2010.mkv"。数据库中无此记录。
    *   **When:** 完整运行`scanner`和`processor`后台任务。
        *   模拟LLM返回 `{"title": "Inception", "year": "2010", ...}`。
        *   模拟TMDB返回《盗梦空间》的正确信息。
        *   模拟文件链接成功。
    *   **Then:**
        *   数据库中该文件的状态依次经历了 `PENDING` -> `PROCESSING` -> `COMPLETED`。
        *   虚拟文件系统的"目标目录"下出现了名为 "Inception (2010)/Inception (2010).mkv" 的文件。

*   **测试用例 6.2: LLM处理失败流程**
    *   **Given:** 一个新文件。
    *   **When:** 完整运行后台任务，但模拟LLM在重试后依然永久性失败。
    *   **Then:**
        *   数据库中该文件的最终状态为`FAILED`，且有相关的错误信息。
        *   "目标目录"中没有创建任何新文件。

*   **测试用例 6.3: TMDB处理失败流程**
    *   **Given:** 一个新文件，LLM成功返回结果。
    *   **When:** 完整运行后台任务，但模拟TMDB永久性失败或找不到结果。
    *   **Then:**
        *   数据库中该文件的最终状态为`FAILED`。
        *   "目标目录"中没有创建任何新文件。

*   **测试用-例 6.4: 文件链接冲突流程**
    *   **Given:** 一个新文件，且LLM和TMDB都成功。但在虚拟文件系统的"目标目录"下**预先创建**一个同名文件。
    *   **When:** 完整运行后台任务。
    *   **Then:**
        *   数据库中该文件的最终状态为`CONFLICT`。
        *   "目标目录"中预先创建的文件保持原样，没有被覆盖。