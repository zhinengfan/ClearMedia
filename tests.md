### **ClearMedia 项目测试用例指南**

**核心测试理念:**
我们将采用`pytest`作为测试框架。测试将分为**单元测试**（测试单个模块/函数）和**集成测试**（测试多个模块协同工作的流程）。我们将大量使用**Mocks（模拟）**来隔离外部依赖（如LLM/TMDB API），并使用**Fixtures（固定装置）**来创建可复用的测试环境（如内存数据库、虚拟文件系统）。

**推荐的测试库(已安装):**
*   `pytest`: 核心测试框架。
*   `pytest-mock`: 方便地模拟对象和函数。
*   `pyfakefs`: 创建一个虚拟的内存文件系统，用于测试所有文件操作。

---

#### **1. `config.py` - 配置模块单元测试 (`test_config.py`)**

*   **测试用例 1.1: 成功加载配置**
    *   **Given:** 一个包含所有必需变量的有效`.env`文件。
    *   **When:** `Settings`类被实例化。
    *   **Then:** `settings`对象的属性值与`.env`文件中的值完全匹配。

*   **测试用例 1.2: 缺少环境变量**
    *   **Given:** 一个缺少了`TMDB_API_KEY`等必需变量的`.env`文件。
    *   **When:** `Settings`类被实例化。
    *   **Then:** 程序应抛出`pydantic_settings`的验证错误 (Validation Error)。

---

#### **2. `scanner.py` - 扫描器单元测试 (`test_scanner.py`)**
*(需要使用 `pyfakefs` 模拟文件系统和 `pytest-mock` 模拟数据库交互)*

*   **测试用例 2.1: 发现新文件**
    *   **Given:** "源目录"中存在一个数据库中没有记录的新视频文件。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数被以正确的文件路径、inode、device_id和`PENDING`状态调用了一次。

*   **测试用例 2.2: 忽略已处理的文件**
    *   **Given:** "源目录"中存在一个文件，其inode和device_id在数据库中已存在，状态为`COMPLETED`。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

*   **测试用例 2.3: 忽略处理失败的文件**
    *   **Given:** "源目录"中存在一个文件，其inode和device_id在数据库中已存在，状态为`FAILED`。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

*   **测试用例 2.4: 忽略非视频文件**
    *   **Given:** "源目录"中出现了一个`.txt`或`.nfo`文件。
    *   **When:** 扫描器任务运行。
    *   **Then:** 数据库的“创建新文件记录”函数**未被调用**。

---

#### **3. `llm.py` - LLM交互单元测试 (`test_llm.py`)**
*(需要使用 `pytest-mock` 模拟`openai`客户端)*

*   **测试用例 3.1: 成功解析规范文件名**
    *   **Given:** 输入文件名 "Dune.Part.Two.2024.1080p.mkv"。
    *   **When:** 调用LLM分析函数。
    *   **Then:** 函数应返回一个类似 `{"title": "Dune Part Two", "year": "2024", "type": "movie"}` 的JSON对象。

*   **测试用例 3.2: 优雅处理不规范文件名**
    *   **Given:** 输入文件名 "沙丘2.mkv"。
    *   **When:** 调用LLM分析函数。
    *   **Then:** 函数应能返回一个合理的猜测结果，例如 `{"title": "沙丘2", "year": null, "type": "movie"}`。

*   **测试用例 3.3: API调用失败与重试**
    *   **Given:** 模拟`openai`客户端在前两次调用时抛出`APIError`，第三次调用时成功。
    *   **When:** 调用LLM分析函数（该函数已被`@tenacity.retry`装饰）。
    *   **Then:** 函数最终成功返回结果，并且可以断言底层的API客户端被调用了**3次**。

*   **测试用例 3.4: 验证缓存机制**
    *   **Given:** 模拟`openai`客户端。
    *   **When:** 使用**相同的**文件名连续调用LLM分析函数（该函数已被`@functools.lru_cache`装饰）两次。
    *   **Then:** 底层的API客户端应该只被调用了**1次**。

---

#### **4. `tmdb.py` - TMDB交互单元测试 (`test_tmdb.py`)**
*(需要使用 `pytest-mock` 模拟 `tmdbsimple` 和 `asyncio.to_thread`)*

*   **测试用例 4.1: 成功找到匹配项**
    *   **Given:** 输入从LLM获取的有效数据 `{"title": "Dune Part Two", "year": "2024"}`。
    *   **When:** 调用TMDB搜索函数。
    *   **Then:** 函数应返回一个包含正确TMDB ID和媒体信息的对象。

*   **测试用例 4.2: 未找到匹配项**
    *   **Given:** 输入一个无法匹配任何电影的数据 `{"title": "一部不存在的电影", "year": "1900"}`。
    *   **When:** 调用TMDB搜索函数。
    *   **Then:** 函数应返回`None`或一个表示失败的空结果。

*   **测试用例 4.3: 验证异步包装**
    *   **Given:** 任何有效的输入。
    *   **When:** `await`调用TMDB搜索函数。
    *   **Then:** `asyncio.to_thread`应该被调用，并且函数应成功执行完毕，没有阻塞测试的事件循环。

---

#### **5. `linker.py` - 文件链接器单元测试 (`test_linker.py`)**
*(需要使用 `pyfakefs` 模拟文件系统)*

*   **测试用例 5.1: 成功创建硬链接**
    *   **Given:** 源文件和目标目录在同一个模拟设备上。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 目标路径下出现了一个新的硬链接文件，并且该函数返回成功状态。

*   **测试用例 5.2: 目标路径已存在冲突**
    *   **Given:** 目标路径下已经存在一个同名文件。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 底层的`os.link`**未被调用**，函数返回一个`CONFLICT`状态。

*   **测试用例 5.3: 跨设备链接失败**
    *   **Given:** 模拟`os.link`在被调用时抛出`OSError`（特别是`errno.EXDEV`）。
    *   **When:** 调用创建硬链接的函数。
    *   **Then:** 函数能捕获这个异常，并返回一个`FAILED`状态。

---

#### **6. `queue.py` & `processor.py` - 集成测试 (`test_processing_flow.py`)**
*(需要真实的内存SQLite数据库和模拟的API/文件系统)*

*   **测试用例 6.1: 端到端成功流程**
    *   **Given:** 在虚拟文件系统中有一个新文件 "Inception.2010.mkv"。数据库中无此记录。
    *   **When:** 完整运行`scanner`和`processor`后台任务。
        *   模拟LLM返回 `{"title": "Inception", "year": "2010", ...}`。
        *   模拟TMDB返回《盗梦空间》的正确信息。
        *   模拟文件链接成功。
    *   **Then:**
        *   数据库中该文件的状态依次经历了 `PENDING` -> `PROCESSING` -> `COMPLETED`。
        *   虚拟文件系统的"目标目录"下出现了名为 "Inception (2010)/Inception (2010).mkv" 的文件。

*   **测试用例 6.2: LLM处理失败流程**
    *   **Given:** 一个新文件。
    *   **When:** 完整运行后台任务，但模拟LLM在重试后依然永久性失败。
    *   **Then:**
        *   数据库中该文件的最终状态为`FAILED`，且有相关的错误信息。
        *   "目标目录"中没有创建任何新文件。

*   **测试用例 6.3: TMDB处理失败流程**
    *   **Given:** 一个新文件，LLM成功返回结果。
    *   **When:** 完整运行后台任务，但模拟TMDB永久性失败或找不到结果。
    *   **Then:**
        *   数据库中该文件的最终状态为`FAILED`。
        *   "目标目录"中没有创建任何新文件。

*   **测试用-例 6.4: 文件链接冲突流程**
    *   **Given:** 一个新文件，且LLM和TMDB都成功。但在虚拟文件系统的"目标目录"下**预先创建**一个同名文件。
    *   **When:** 完整运行后台任务。
    *   **Then:**
        *   数据库中该文件的最终状态为`CONFLICT`。
        *   "目标目录"中预先创建的文件保持原样，没有被覆盖。



### **模块测试用例指南 (补充版)**

#### **`queue.py` - 原子任务队列单元测试 (`test_queue.py`)**
*(这个模块的测试相对复杂，因为它需要模拟并发场景。测试时，我们会使用真实的内存SQLite数据库，但可能需要借助多线程或`asyncio`来模拟并发的工作者。)*

*   **测试用例 1: 成功获取唯一任务**
    *   **场景描述 (Given):** 数据库中存在一个状态为 `PENDING` 的任务。
    *   **执行动作 (When):** 调用一次 `acquire_next_task` 函数。
    *   **预期结果 (Then):**
        1.  函数应成功返回一个 `MediaFile` 对象。
        2.  在函数返回后，查询数据库，该返回对象的 `status` 字段应已变为 `PROCESSING`。

*   **测试用例 2: 队列为空时获取任务**
    *   **场景描述 (Given):** 数据库中**没有**任何状态为 `PENDING` 的任务。
    *   **执行动作 (When):** 调用 `acquire_next_task` 函数。
    *   **预期结果 (Then):**
        1.  函数应返回 `None`。
        2.  数据库中没有任何记录的状态发生改变。

*   **测试用例 3: 验证原子性 - 模拟并发获取 (核心测试)**
    *   **场景描述 (Given):** 数据库中**只有一个**状态为 `PENDING` 的任务。
    *   **执行动作 (When):**
        1.  (如果使用 `asyncio`) 使用 `asyncio.gather` 同时启动**两个**模拟的“工作者”协程。
        2.  每个工作者协程都调用一次 `acquire_next_task` 函数。
    *   **预期结果 (Then):**
        1.  **只有一个**工作者成功获取到了任务对象。
        2.  **另一个**工作者返回了 `None`。
        3.  数据库中该任务的 `status` 最终变为 `PROCESSING`，并且在整个过程中没有发生错误或死锁。

*   **测试用例 4: 跳过已锁定的任务**
    *   **场景描述 (Given):** 数据库中存在两个状态为 `PENDING` 的任务（任务A和任务B）。
    *   **执行动作 (When):**
        1.  在一个模拟的数据库事务中，手动查询并锁定任务A（但不提交事务，以保持锁定状态）。
        2.  在保持任务A锁定的同时，调用 `acquire_next_task` 函数。
    *   **预期结果 (Then):**
        1.  `acquire_next_task` 函数应该能**跳过**被锁定的任务A。
        2.  函数应该成功获取并返回**任务B**。
        3.  任务B的状态应变为 `PROCESSING`。

*   **测试用例 5: 任务处理失败后，状态不应自动回滚**
    *   **场景描述 (Given):** 一个工作者通过 `acquire_next_task` 成功获取了一个任务，使其状态变为 `PROCESSING`。
    *   **执行动作 (When):** 模拟这个工作者在后续处理中发生崩溃或异常（不涉及`queue.py`的逻辑，而是`processor.py`的职责）。
    *   **预期结果 (Then):**
        1.  数据库中该任务的状态**仍然是 `PROCESSING`**。
        2.  这验证了`acquire_next_task`的职责仅限于“获取和锁定”，后续的状态管理由其他模块负责。*(这可以引出未来可能的功能：一个“看门狗”任务，用于清理长时间处于`PROCESSING`状态的僵尸任务)*。